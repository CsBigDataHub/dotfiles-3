#!/bin/bash

# set -o xtrace
set -o pipefail
set -o errexit
set -o nounset

show_help() {
cat << EOF
Usage: ${0##*/} [-nwm] <source> <target>

Setup the dotfiles for a computer.  The system type is detected
automatically.

    -c          publish dotfiles using cp
    -n          dryrun, don't acutally do anything
    -s          publish dotfiles using symlinks, the default
    -h          display the help
EOF
}

dryrun=false
copy_items=false
link_items=false

OPTIND=1
while getopts ":ncsh" opt; do
    case "$opt" in
        n) dryrun=true ;;
        c) copy_items=true ;;
        s) link_items=true ;;
        h) show_help
           exit ;;
        \?) echo "Invalid option: -$OPTARG" >&2
            exit 1
            ;;
    esac
done
shift "$((OPTIND - 1))"

if "$copy_items" && "$link_items"; then
    printf "Cannot specify both -w (windows build) and -m (mac build).  Pick \
 one or the other.\n"
    exit 1
fi

PUBLISH_CMD=''
published=''
if "$copy_items"; then
    PUBLISH_CMD='cp -r '
    published='copied'
elif "$link_items"; then
    PUBLISH_CMD='ln -s '
    published='linked'
else
    case "$OSTYPE" in
        darwin*)
            PUBLISH_CMD="ln -s"
            published='linked'
            ;;
        msys*)
            PUBLISH_CMD='cp -r '
            published='copied'
            ;;
        \?)
            PUBLISH_CMD="ln -s"
            published='linked'
            ;;
    esac
fi

# shellcheck disable=2059
function items_identical {
    local diff_cmd="diff --ignore-all-space \
         --ignore-blank-lines \
         --brief \
         $source_path $target_path > /dev/null"

    # diff returns 0 if the folders were identical
    if eval "$diff_cmd"; then
        printf "$skip: $target is identical to $source\n"
        return 0
    else
        return 1
    fi
}

# Link or copy item into the home directory.
#
# Link on Unix-like OS, copy on Windows because it doesn't support
# symbolic links.
function publish_item {
    if [[ $# -ne 2 ]]; then
        echo "publish_item takes 2 arguments" >&2
        return 1
    fi
    if "$dryrun"; then
        echo "dryrun: $PUBLISH_CMD $1 $2"
    else
        eval "$PUBLISH_CMD $1 $2"
    fi
}

RESTORE='\033[0m'
RED='\033[00;31m'
GREEN='\033[00;32m'
YELLOW='\033[00;33m'

ok="${GREEN}    ok${RESTORE}"
skip="${GREEN}  skip${RESTORE}"
warn="${YELLOW}  warn${RESTORE}"
error="${RED} error${RESTORE}"


realpath() {
    local dir=$(echo "${1%/*}")
    (cd "$dir" && echo "$(pwd -P)")
}

# shellcheck disable=2059
function publish {
    local source="$1"
    local source_path="$source"
    local target="$2"
    local target_path="$target"

    local start_dir="$(pwd)"

    # Does the target exist?
    #
    # Don't use target_path, because realpath will truncate the
    # path until it's an actual directory
    if [[ ! -e "$target" ]]; then

        if publish_item "$source" "$target"; then
            printf "$ok: $source is now $published to $target\n"
            return 0
        else
            printf "$error: failed to $publish $source to $target\n"
            return 1
        fi

    # Is the target a symlink?
    elif [[ -h "$target_path" ]]; then
        existing_target=$(readlink "$target_path")

        if [[ "$existing_target" = "$source_path" ]]; then
            printf "$skip: $source is already linked by $target\n"
        else
            printf "$error: $target points to $existing_target instead of $source\n"
        fi

    #  Is the target already a directory?
    elif [[ -d "$target_path" ]]; then

        # Is our source a directory too?
        if [[ -d "$source_path" ]]; then

            if items_identical "$source_path" "$target_path"; then
                printf "$skip: $target is identical to $source\n"

            # the folders were not identical
            else
                # Check if the target has more files.  If it does,
                # warn that some files exist in target, but not in
                # source
                cd "$target"
                local excess_target_files=$(find . \
                                                 -not -path . \
                                                 -exec test ! -e "$source_path/{}" \; \
                                                 -print)
                cd "$start_dir"
                [[ "$excess_target_files" ]] && \
                for f in $excess_target_files; do
                    f=$(basename "$f")
                    printf "$warn: $target/$f is excess compared to $source\n"
                done

                # Compare files that are in both source and target
                cd "$source_path"
                local same_files=$(find . \
                                        -not -path . \
                                        -exec test -e "$target_path/{}" \; \
                                        -print)
                cd "$start_dir"
                for same_file in $same_files; do
                    local target_same="$target_path/$same_file"
                    local source_same="$source_path/$same_file"
                    same_file=$(basename "$same_file")
                    if items_identical "$source_same" "$target_same"; then
                        printf "$skip: $same_file is identical in $source and $target\n"
                    else
                        printf "$error: $source/$same_file is different from $target/$same_file\n"
                    fi
                done

                # Copy files that don't exist in target from source
                cd "$source_path"
                local excess_source_files=$(find . \
                                                 -not -path . \
                                                 -exec test ! -e "$target_path/{}" \; \
                                                 -print)
                cd "$start_dir"
                for source_file in $excess_source_files; do
                    publish_item "$source_path/$source_file" "$target"
                    source_file=$(basename "$source_file")
                    printf "$ok: $source/$source_file $published to $target\n"
                done

            fi
        # So the target is a directory, but our source isn't.
        else
            printf "$error: $target is a directory, but $source is a file\n"
            return 1
        fi

    # Does the file exist and is it regular?
    elif [[ -f "$target" ]]; then

        # Compare source file to target
        # First, check to see that source is also a file
        if [[ -f "$source" ]]; then
            if items_identical "$source" "$target"; then
                printf "$skip: $source and $target are identical\n"
                return 0
            else
                printf "$error: $source and $target are different\n"
                return 1
            fi
        else
            printf "$error: $source is a directory, but $target is a file"
            return 1
        fi

    elif publish_item "$source_path" "$target_path"; then
        printf "$ok: $source is now $published to $target\n"
        return 0

    # Something went wrong
    else
        printf "$error: linking $source failed\n"
        return 1
    fi
}

function publish_dotfiles {
    # First dotfiles
    for f in $HOME/.dotfiles/home/.[!.]*; do
        publish "$f" "$HOME/$(basename $f)"
    done

    # And everything else
    for f in $HOME/.dotfiles/home/*; do
        publish "$f" "$HOME/$(basename $f)"
    done
}

if [[ $# -gt 0 ]]; then
    echo "error: $0 doesn't take positional arguments" >&2
    show_help
    exit 1
fi

if "$dryrun"; then
    printf "Executing a dryrun\n"
fi
publish_dotfiles
