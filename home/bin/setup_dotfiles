#!/bin/bash

# set -o xtrace
set -o pipefail
set -o errexit
set -o nounset

show_help() {
cat << EOF
Usage: ${0##*/} [-nwm] <source> <target>

Setup the dotfiles for a computer.  The system type is detected
automatically.

    -c          publish dotfiles using cp
    -n          dryrun, don't acutally do anything
    -s          publish dotfiles using symlinks, the default
    -h          display the help
EOF
}

dryrun=false
copy_items=false
link_items=false

OPTIND=1
while getopts ":ncsh" opt; do
    case "$opt" in
        n) dryrun=true ;;
        c) copy_items=true ;;
        s) link_items=true ;;
        h) show_help
           exit ;;
        \?) echo "Invalid option: -$OPTARG" >&2
            exit 1
            ;;
    esac
done
shift "$((OPTIND - 1))"

if "$copy_items" && "$link_items"; then
    printf "Cannot specify both -w (windows build) and -m (mac build).  Pick \
 one or the other.\n"
    exit 1
fi

PUBLISH_CMD=''
published=''
if "$copy_items"; then
    PUBLISH_CMD='cp -r '
    published='copied'
elif "$link_items"; then
    PUBLISH_CMD='ln -s '
    published='linked'
else
    case "$OSTYPE" in
        darwin*)
            PUBLISH_CMD="ln -s"
            published='linked'
            ;;
        msys*)
            PUBLISH_CMD='cp -r '
            published='copied'
            ;;
        \?)
            PUBLISH_CMD="ln -s"
            published='linked'
            ;;
    esac
fi

# shellcheck disable=2059
function items_identical {
    local diff_cmd="diff --ignore-all-space \
         --ignore-blank-lines \
         --brief \
         $source $target > /dev/null"

    # diff returns 0 if the folders were identical
    if eval "$diff_cmd"; then
        printf "$skip: $target_pretty is identical to $source_pretty\n"
        return 0
    else
        return 1
    fi
}

# Link or copy item into the home directory.
#
# By default, link on Unix-like OS, copy on Windows because it doesn't
# support symbolic links.
function publish_item {
    if [[ $# -ne 2 ]]; then
        echo "publish_item takes 2 arguments" >&2
        return 1
    fi
    if "$dryrun"; then
        echo "dryrun: $PUBLISH_CMD $1 $2"
    else
        eval "$PUBLISH_CMD $1 $2"
    fi
}

RESTORE='\033[0m'
RED='\033[00;31m'
GREEN='\033[00;32m'
YELLOW='\033[00;33m'

ok="${GREEN}    ok${RESTORE}"
skip="${GREEN}  skip${RESTORE}"
warn="${YELLOW}  warn${RESTORE}"
error="${RED} error${RESTORE}"


realpath() {
    local dir=$(echo "${1%/*}")
    (cd "$dir" && echo "$(pwd -P)")
}

# shellcheck disable=2059
function publish {
    local source="$1"
    local target="$2"

    # replace home directory with tilde
    local source_pretty=${source/"$HOME"/'~'}
    local target_pretty=${target/"$HOME"/'~'}

    # Does the target exist?
    #
    # Don't use target, because realpath will truncate the
    # path until it's an actual directory
    if [[ ! -e "$target" ]]; then

        if publish_item "$source" "$target"; then
            printf "$ok: $source_pretty is now $published to $target_pretty\n"
            return 0
        else
            printf "$error: $source_pretty was not $published to $target_pretty\n"
            return 1
        fi

    # Is the target a symlink?
    elif [[ -h "$target" ]]; then
        existing_target=$(readlink "$target")

        if [[ "$existing_target" = "$source" ]]; then
            printf "$skip: $source_pretty is already linked by $target_pretty\n"
        else
            printf "$error: $target_pretty points to $existing_target_pretty instead of $source_pretty\n"
        fi

    #  Is the target already a directory?
    elif [[ -d "$target" ]]; then

        # Is our source a directory too?
        if [[ -d "$source" ]]; then

            if items_identical "$source" "$target"; then
                printf "$skip: $target_pretty is identical to $source_pretty\n"

            # the folders were not identical
            else
                # Check if the target has more files.  If it does,
                # warn that some files exist in target, but not in
                # source
                local files_in_target=$(find "$target" -not -path .)
                for file in $files_in_target; do
                    file=$(basename "$file")
                    if [[ ! -e "$source/$file" ]]; then
                        printf "$warn: $target_pretty/$file is excess compared to $source_pretty\n"
                    fi
                done

                # Compare files that are in both source and target
                local files_in_source=$(find "$source" -not -path .)
                for file in $files_in_source; do
                    file=$(basename "$file")
                    if [[ -e "$target/$file" ]]; then
                        if items_identical "$source/$file" "$target/$file"; then
                            printf "$skip: $source_pretty/$file is identical in $source_pretty and $target_pretty\n"
                        else
                            printf "$error: $source_pretty/$file is different from $target_pretty/$file\n"
                        fi
                    fi
                done

                # Copy files that don't exist in target from source
                for file in $files_in_source; do
                    file=$(basename "$file")
                    if [[ ! -e "$target/$file" ]]; then
                        publish_item "$source/$file" "$target"
                        printf "$ok: $source_pretty/$file $published to $target_pretty\n"
                    fi
                done
            fi
        # So the target is a directory, but our source isn't.
        else
            printf "$error: $target_pretty is a directory, but $source_pretty is a file\n"
            return 1
        fi

    # Does the file exist and is it regular?
    elif [[ -f "$target" ]]; then

        # Compare source file to target
        # First, check to see that source is also a file
        if [[ -f "$source" ]]; then
            if items_identical "$source" "$target"; then
                printf "$skip: $source_pretty and $target_pretty are identical\n"
                return 0
            else
                printf "$error: $source_pretty and $target_pretty are different\n"
                return 1
            fi
        else
            printf "$error: $source_pretty is a directory, but $target_pretty is a file"
            return 1
        fi

    elif publish_item "$source" "$target"; then
        printf "$ok: $source_pretty is now $published to $target_pretty\n"
        return 0

    # Something went wrong
    else
        printf "$error: linking $source_pretty failed\n"
        return 1
    fi
}

# Return all files in a directory except '.'
function find_files_to_publish {
    find "$1" -mindepth 1 -maxdepth 1
}

# shellcheck disable=2059
function publish_dotfiles {
    # First dotfiles
    local dotfiles=$(find_files_to_publish "$HOME/.dotfiles/home")
    for f in $dotfiles; do
        publish "$f" "$HOME/$(basename $f)" || true
   done

    local system_home_dir=''
    case "$OSTYPE" in
        darwin*) system_home_dir="home-mac" ;;
        msys*) system_home_dir="home-win" ;;
        \?*) printf "$warn: unknown 'OSTYPE', skipping system config\n"
             exit 0
             ;;
    esac

    local system_dotfiles=$(find_files_to_publish "$HOME/.dotfiles/$system_home_dir")
    for f in $system_dotfiles; do
        publish "$f" "$HOME/$(basename $f)" || true
    done
}

if [[ $# -gt 0 ]]; then
    echo "error: $0 doesn't take positional arguments" >&2
    show_help
    exit 1
fi

if "$dryrun"; then
    printf "Executing a dryrun\n"
fi

publish_dotfiles
