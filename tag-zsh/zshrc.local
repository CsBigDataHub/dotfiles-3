#!/bin/zsh

# ZSH loads the following files in order on startup for interactive shells.
# /etc/zshenv
# ~/.zshenv
# /etc/zprofile
# ~/.zprofile
# /etc/zshrc
# ~/.zshrc
# /etc/zlogin
# ~/.zlogin


# Log zsh startup information to this file.  Used mainly to debug why files
# aren't sourced and $PATH isn't updated.
INIT_LOG_FILE="${HOME}/.zsh-init-log"

function setup-init-log() {
    if [[ -f "${INIT_LOG_FILE}" ]]; then
        touch "${INIT_LOG_FILE}"
    fi

    # Clear the file
    echo -n '' > "${INIT_LOG_FILE}"
}

function log-to-zsh-init-log() {
    printf "%s\n" "$1" >> "${INIT_LOG_FILE}"
}

function show-init-log() {
    cat "${INIT_LOG_FILE}"
}

# This option is a variant of INC_APPEND_HISTORY in which, where possible, the
# history entry is written out to the file after the command is finished, so
# that the time taken by the command is recorded correctly in the history file
# in EXTENDED_HISTORY format. This means that the history entry will not be
# available immediately from other instances of the shell that are using the
# same history file.
setopt inc_append_history_time

autoload colors
if [[ "$terminfo[colors]" -gt 8 ]]; then
    colors
fi

function include () {
    if [[ -e "$1" ]]; then
        log-to-zsh-init-log "Sourcing $1"
        source "$1"
    else
        log-to-zsh-init-log "WARNING: didn't source $1"
    fi
}

function print-white() {
  echo "$fg[white]$1$reset_color"
}

function print-info() {
  print-white "$1"
}

function print-green() {
  echo "$fg[green]$1$reset_color"
}

function print-success() {
  local message="$1"
  print-green "ï€Œ  ${message}"
}

function print-red() {
  echo "$fg[red]$1$reset_color"
}

function print-error() {
  local message="$1"
  print-red "ERROR: ${message}"
}

function setup-env-variables() {
    include "${HOME}/.shell-common.sh"
}

function setup-zgen() {
    include "${DOTFILES_HOME}/vendor/zgen/zgen.zsh"

    if ! zgen saved; then

        # Provides syntax highlighting like the fish shell while typing
        # interactive commands.
        zgen load zsh-users/zsh-syntax-highlighting

        # k is a zsh script / plugin to make directory listings more readable,
        # adding a bit of color and some git status information on files and
        # directories.
        zgen load supercrabtree/k

        # More completion files for zsh.
        zgen load zsh-users/zsh-completions src

        # A Zsh plugin to help remembering those shell aliases and Git aliases
        # you once defined.  Prints a help line reminding you of an alias for a
        # command you typed.
        # zgen load djui/alias-tips
        zgen load jschaf/alias-tips

        # Type in any part of any previously entered command and press the UP
        # and DOWN arrow keys to cycle through the matching commands.  Substring
        # search must load search after zsh-syntax-highlighting.
        zgen load zsh-users/zsh-history-substring-search

        # With zsh-async you can run multiple asynchronous jobs, enforce unique
        # jobs (multiple instances of the same job will not run), flush all
        # currently running jobs and create multiple workers (each with their
        # own jobs). For each worker you can register a callback-function
        # through which you will be notified about the job results (job name,
        # return code, output and execution time).
        zgen load mafredri/zsh-async

        zgen load rupa/z

        # Generate the init script from plugins above.
        zgen save
    fi

    # Exclude alias tips for commands that I sometimes type out manually.
    export ZSH_PLUGINS_ALIAS_TIPS_EXCLUDES="git"
}

function contains() {
    string="$1"
    substring="$2"
    if test "${string#*$substring}" != "$string"
    then
        return 0    # $substring is in $string
    else
        return 1    # $substring is not in $string
    fi
}

function add-to-colon-separated-env-var() {
    local envKey="$1"
    local envValue="${(P)1}"
    local pathToAdd="$2"
    local insertLocation="$3"

    if ! contains "${envValue}" "${pathToAdd}" ; then
        if [ "${insertLocation}" = "after" ] ; then
            eval "${envKey}=${envValue}:${pathToAdd}"
            log-to-zsh-init-log "Added ${pathToAdd} to \$${envKey} at back.  \$${envKey} is now: ${(P)envKey}"
        else
            eval "${envKey}=${pathToAdd}:${envValue}"
            log-to-zsh-init-log "Added ${pathToAdd} to \$${envKey} at back.  \$${envKey} is now: ${(P)envKey}"
        fi
    fi
}

function add-to-path () {
    add-to-colon-separated-env-var PATH "$1" "$2"
}

function add-to-manpath() {
    add-to-colon-separated-env-var MANPATH "$1" "$2"
}

function add-to-path-if-exists() {
    if [[ -d "$1" ]]; then
        add-to-path "$1" "$2"
    else
        log-to-zsh-init-log "WARNING: didn't add to \$PATH because path doesn't exist: $1"
    fi
}

# Fix binding for delete key.
bindkey '^[[P' delete-char

function setup-gpg() {
    GPG_TTY=$(tty)
    export GPG_TTY
    log-to-zsh-init-log "Exported \$GPG_TTY as $GPG_TTY"
}

function setup-gpg-agent() {
    local hostUniqueName="$(hostname)"
    local lockFile="${HOME}/.gnupg/gpg-agent-info-${hostUniqueName}"
    local gpgAgentPid=$(cut -d: -f 2 "${lockFile}")
    local gpgAgentLog="${HOME}/.gnupg/gpg-agent-log"
    # kill -0 $PID tests if $PID is running.
    if test -f "${lockFile}" && kill -0 "${gpgAgentPid}" 2>/dev/null; then
        GPG_AGENT_INFO=$(< "${lockFile}")
        export GPG_AGENT_INFO
        local logMessage="gpg-agent already running, "
        logMessage+="exported \$GPG_AGENT_INFO as $GPG_AGENT_INFO"
        log-to-zsh-init-log "${logMessage}"
    else
        eval $(gpg-agent --daemon --write-env-file "${lockFile}" \
                         --log-file "${gpgAgentLog}")
        echo $GPG_AGENT_INFO > "${lockFile}"
        local logMessage="Started gpg-agent, "
        logMessage+="wrote \$GPG_AGENT_INFO to ${lockFile}"
        log-to-zsh-init-log "${logMessage}"
    fi
}


function reload-zshrc() {
    source ~/.zshrc.local
}

function reload-zshrc-profile() {
    ZSH_PROFILE_RC=1 reload-zshrc
    zprof | less
}

function setup-prompt() {
    # Disable grml prompt.
    prompt off
    include "${HOME}/.config/zsh/current-org-task.zsh"
    include "${HOME}/.config/zsh/prompt.zsh"
}

function reload-prompt() {
    include "${HOME}/.config/zsh/prompt.zsh"
}

# Package Setup

# Set keystrokes for substring searching
function setup-zsh-history-substring-search() {
    # OPTION 1: for most systems
    zmodload zsh/terminfo
    bindkey "$terminfo[kcuu1]" history-substring-search-up
    bindkey "$terminfo[kcud1]" history-substring-search-down

    # OPTION 2: for iTerm2 running on Apple MacBook laptops
    zmodload zsh/terminfo
    bindkey "$terminfo[cuu1]" history-substring-search-up
    bindkey "$terminfo[cud1]" history-substring-search-down

    ## EMACS mode ###########################################
    bindkey -M emacs '^P' history-substring-search-up
    bindkey -M emacs '^N' history-substring-search-down
}

# fzf is a general-purpose command-line fuzzy finder.
function setup-fzf() {
    local fzfPath="${HOME}/.dotfiles/vendor/fzf"

    add-to-path "${fzfPath}/bin" after
    add-to-manpath "${fzfPath}/man" after

    # Auto-completion
    [[ $- == *i* ]] && include "${fzfPath}/shell/completion.zsh" 2> /dev/null

    # Key bindings
    include "${fzfPath}/shell/key-bindings.zsh"
}

# Setup NPM so we can install global packages without root.  See
# http://stackoverflow.com/questions/10081293.
function setup-npm() {
  add-to-path-if-exists "${NPM_PACKAGES}/bin"
  add-to-manpath "${NPM_PACKAGES}/share/man"
}

# Setup Ruby and Gem so we install packages without root.
function setup-ruby() {
  add-to-path-if-exists "${GEM_HOME}/bin"
}

# Setup PATH and completion for gcloud.
function setup-gcloud() {
  include "${HOME}/google-cloud-sdk/path.zsh.inc"
  include "${HOME}google-cloud-sdk/completion.zsh.inc"
}

function setup-personal-packages() {
    include "${HOME}/.config/zsh/extract.zsh"
    include "${HOME}/.config/zsh/eslint.zsh"
    include "${HOME}/.config/zsh/finances.zsh"
    include "${HOME}/.config/zsh/utils.zsh"
    include "${HOME}/.config/zsh/spectrum.zsh"
    include "${HOME}/.config/zsh/updater.zsh"
    include "${HOME}/.config/zsh/tmuxp.zsh"
    include "${HOME}/.config/zsh/test-fonts.zsh"
    include "${HOME}/.config/zsh/current-org-task.zsh"
}

function is-google-corp-computer() {
  if [[ $(hostname) == *corp.google.com ]]; then
    return 0
  else
    return 1
  fi
}

function setup-google-packages() {
  if is-google-corp-computer; then
    include "${HOME}/.config/zsh/google.zsh"
  fi
}

function setup-rust() {
    add-to-path-if-exists "${HOME}/.cargo/bin"
    export RUST_SRC_PATH="${HOME}/.multirust/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src"
}

function setup-yarn() {
  if ! command -v yarn >/dev/null; then
    add-to-path-if-exists "${HOME}/.yarn/bin"
  fi
}

# Tmux inside the st terminal doesn't like it when TERM isn't xterm-256 and
# won't properly display the background color.  fzf, on the other hand only
# likes TERM to screen-256color.  So, let TERM start as xterm-256color, but
# after tmux is started we can safely change TERM to screen-256color to appease
# fzf.
function setup-256-color-hack-for-fzf() {
  if [[ -n "$TMUX" ]]; then
    export TERM='screen-256color'
  fi
}

setup-init-log
setup-env-variables
setup-zgen
setup-npm
setup-ruby
setup-rust
setup-256-color-hack-for-fzf

# Useful functions
function npm-do {
    PATH=$(npm bin):$PATH; eval $@;
}


# Keyboard shortcuts

# Store the current command and use it as the inital text for following
# commands.
bindkey '^[q' push-input

# Options
setopt interactive_comments

# Path Setup
#
# View adding paths without a second arg of 'after' like a stack, so the last
# entry is the first directory searched for executables.
add-to-path-if-exists "/usr/share/texmf-dist/scripts/texlive"
add-to-path-if-exists "${HOME}/.cask/bin"
add-to-path "/usr/local/bin"
add-to-path-if-exists "/usr/local/sbin"
add-to-path-if-exists "$HOME/homebrew/bin"

add-to-path-if-exists "$HOME/prog/bin"
add-to-path "$HOME/bin"
add-to-path "$HOME/bin-system"

setup-zsh-history-substring-search
setup-prompt
setup-personal-packages
setup-google-packages
setup-fzf
setup-gcloud
setup-yarn

# Check for updates
ensure-tmux-package-manager-is-installed

alias g='git'
alias gRl='git remote --verbose'
alias kl='k -l'
alias ka='k -a'
alias kh='k -h'
alias rz='reload-zshrc'
alias e='emacsclient --no-wait'

export DISABLE_AUTO_TITLE='true'

if ! type 'blaze' > /dev/null; then
  alias blaze='bazel'
fi

alias hl='hledger -f ~/gdrive/financials/personal.ledger'
alias open='xdg-open'

if alias | grep -q '^ag='; then
  # This grml alias conflicts with the platinum searcher.
  unalias ag
fi


export MY_ZSH_SYSTEM_LOADED=''
include "${HOME}/.zsh-system.zsh"

if [[ -z "${MY_ZSH_SYSTEM_LOADED}" ]]; then
  print-info "No ZSH system file loaded"
fi
