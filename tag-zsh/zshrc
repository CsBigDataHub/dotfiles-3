#!/bin/zsh

# ZSH loads the following files in order on startup for interactive shells.
# /etc/zshenv
# ~/.zshenv
# /etc/zprofile
# ~/.zprofile
# /etc/zshrc
# ~/.zshrc
# /etc/zlogin
# ~/.zlogin


# For profiling, execute 'ZSH_PROFILE_RC=1 zsh'.  After loading a new shell, run
# `zprof | less`.
if [[ $ZSH_PROFILE_RC -gt 0 ]] ; then
    zmodload zsh/zprof
fi


# Check for user and if not running as root set $SUDO to sudo.  Enables using
# "$SUDO" in command definitions.
(( EUID != 0 )) && SUDO='sudo' || SUDO=''

# Log zsh startup information to this file.  Used mainly to debug why files
# aren't sourced and $PATH isn't updated.
INIT_LOG_FILE="${HOME}/.zsh-init-log"

# The complist module offers two extensions to completion listings: the ability
# to highlight matches in such a list and a different style of menu-completion
zmodload zsh/complist

HISTFILE=$HOME/.zsh_history
HISTSIZE=10000
SAVEHIST=10000

# This option is a variant of INC_APPEND_HISTORY in which, where possible, the
# history entry is written out to the file after the command is finished, so
# that the time taken by the command is recorded correctly in the history file
# in EXTENDED_HISTORY format. This means that the history entry will not be
# available immediately from other instances of the shell that are using the
# same history file.
setopt inc_append_history_time

# Save each command’s beginning timestamp (in seconds since the epoch) and the
# duration (in seconds) to the history file. The format of this prefixed data
# is:
#
# : <beginning time>:<elapsed seconds>;<command>
# : 1472088207:4;sleep 4
setopt extended_history

# Completion configuration.

# The `-U` flag suppresses alias expansion and is recommended for functions
# supplied with zsh.  The `-z` flag marks the function to be loaded natively
# instead of with ksh emulation.  See
# http://stackoverflow.com/questions/12570749
autoload -Uz compinit
[[ -d "${ZDOTDIR:-$HOME}/.zcompdumps" ]] \
    || mkdir -m 0700 -p "${ZDOTDIR:-$HOME}/.zcompdumps"
compinit -d "${ZDOTDIR:-$HOME}/.zcompdumps/${HOST%%.*}-$ZSH_VERSION"
# https://github.com/zsh-users/zsh-completions/blob/master/zsh-completions-howto.org
# has an in-depth explanation on how to write your own completions.
#
# zstyle configures like so:
#
# zstyle <context> <styles>
#
# The context defines where the style will apply. The context is a string of ‘:’
# separated strings: ‘:completion:function:completer:command:argument:tag’ Some
# part can be replaced by , so that ‘:completion:’ is the least specific
# context. More specific context wins over less specific ones of course.

# Format all messages not formatted in bold prefixed with ----.
zstyle ':completion:*' format '%B---- %d%b'
# Format descriptions (notice the vt100 escapes).
zstyle ':completion:*:descriptions'    format $'%{\e[0;31m%}completing %B%d%b%{\e[0m%}'
# Bold and underline normal messages.
zstyle ':completion:*:messages' format '%B%U---- %d%u%b'
# Format in bold red error messages.
zstyle ':completion:*:warnings' format "%B$fg[red]%}---- no match for: $fg[white]%d%b"
# zstyle ':completion:*' accept-exact '*(N)'
zstyle ':completion:*' cache-path ~/.zsh/cache
# Use the tag name as group name.
zstyle ':completion:*' group-name ''
zstyle ':completion:*' menu select
zstyle ':completion:*' use-cache on
# Complete with heuristic of one error per 3 character typed.
zstyle ':completion:*:approximate:*' max-errors 'reply=( $(( ($#PREFIX+$#SUFFIX)/3 )) numeric )'
# Complete sudo commands.
zstyle ':completion:*:sudo:*' command-path /usr/local/sbin /usr/local/bin \
       /usr/sbin /usr/bin /sbin /bin /usr/X11R6/bin

# The key sequence ESC h is normally bound by ZLE to execute the run-help widget
# (see Zsh Line Editor). This invokes the run-help command with the command word
# from the current input line as its argument. By default, run-help is an alias
# for the man command, so this often fails when the command word is a shell
# builtin or a user-defined function. By redefining the run-help alias, one can
# improve the on-line help provided by the shell.
#
# Use zsh-aware run-help instead of just man.
unalias run-help &> /dev/null
autoload run-help

autoload colors
if [[ "$terminfo[colors]" -gt 8 ]]; then
    colors
fi

function setup-init-log() {
    if [[ -f "${INIT_LOG_FILE}" ]]; then
        touch "${INIT_LOG_FILE}"
    fi

    # Clear the file
    echo -n '' > "${INIT_LOG_FILE}"
}

function log-to-zsh-init-log() {
    printf "%s\n" "$1" >> "${INIT_LOG_FILE}"
}

function show-init-log() {
    cat "${INIT_LOG_FILE}"
}

function include () {
    if [[ -e "$1" ]]; then
        log-to-zsh-init-log "Sourcing $1"
        source "$1"
    else
        log-to-zsh-init-log "WARNING: didn't source $1"
    fi
}

function print-white() {
  echo "$fg[white]$1$reset_color"
}

function print-info() {
  print-white "$1"
}

function print-green() {
  echo "$fg[green]$1$reset_color"
}

function print-success() {
  local message="$1"
  print-green "  ${message}"
}

function print-red() {
  echo "$fg[red]$1$reset_color"
}

function print-error() {
  local message="$1"
  print-red "ERROR: ${message}"
}

function setup-env-variables() {
    include "${HOME}/.shell-common.sh"
}

function setup-zgen() {
    include "${DOTFILES_HOME}/vendor/zgen/zgen.zsh"

    if ! zgen saved; then

        # Provides syntax highlighting like the fish shell while typing
        # interactive commands.
        zgen load zsh-users/zsh-syntax-highlighting

        # k is a zsh script / plugin to make directory listings more readable,
        # adding a bit of color and some git status information on files and
        # directories.
        zgen load supercrabtree/k

        # More completion files for zsh.
        zgen load zsh-users/zsh-completions src

        # A Zsh plugin to help remembering those shell aliases and Git aliases
        # you once defined.  Prints a help line reminding you of an alias for a
        # command you typed.
        zgen load djui/alias-tips

        # Type in any part of any previously entered command and press the UP
        # and DOWN arrow keys to cycle through the matching commands.  Substring
        # search must load search after zsh-syntax-highlighting.
        zgen load zsh-users/zsh-history-substring-search

        # With zsh-async you can run multiple asynchronous jobs, enforce unique
        # jobs (multiple instances of the same job will not run), flush all
        # currently running jobs and create multiple workers (each with their
        # own jobs). For each worker you can register a callback-function
        # through which you will be notified about the job results (job name,
        # return code, output and execution time).
        zgen load mafredri/zsh-async

        zgen load rupa/z

        # generate the init script from plugins above
        zgen save
    fi
}

function contains() {
    string="$1"
    substring="$2"
    if test "${string#*$substring}" != "$string"
    then
        return 0    # $substring is in $string
    else
        return 1    # $substring is not in $string
    fi
}

function add-to-colon-separated-env-var() {
    local envKey="$1"
    local envValue="${(P)1}"
    local pathToAdd="$2"
    local insertLocation="$3"

    if ! contains "${envValue}" "${pathToAdd}" ; then
        if [ "${insertLocation}" = "after" ] ; then
            eval "${envKey}=${envValue}:${pathToAdd}"
            log-to-zsh-init-log "Added ${pathToAdd} to \$${envKey} at back.  \$${envKey} is now: ${(P)envKey}"
        else
            eval "${envKey}=${pathToAdd}:${envValue}"
            log-to-zsh-init-log "Added ${pathToAdd} to \$${envKey} at back.  \$${envKey} is now: ${(P)envKey}"
        fi
    fi
}

function add-to-path () {
    add-to-colon-separated-env-var PATH "$1" "$2"
}

function add-to-manpath() {
    add-to-colon-separated-env-var MANPATH "$1" "$2"
}

function add-to-path-if-exists() {
    if [[ -d "$1" ]]; then
        add-to-path "$1" "$2"
    else
        log-to-zsh-init-log "WARNING: didn't add to \$PATH because path doesn't exist: $1"
    fi
}

# Fix binding for delete key.
bindkey '^[[P' delete-char

function setup-gpg() {
    GPG_TTY=$(tty)
    export GPG_TTY
    log-to-zsh-init-log "Exported \$GPG_TTY as $GPG_TTY"
}

function setup-gpg-agent() {
    local hostUniqueName="$(hostname)"
    local lockFile="${HOME}/.gnupg/gpg-agent-info-${hostUniqueName}"
    local gpgAgentPid=$(cut -d: -f 2 "${lockFile}")
    local gpgAgentLog="${HOME}/.gnupg/gpg-agent-log"
    # kill -0 $PID tests if $PID is running.
    if test -f "${lockFile}" && kill -0 "${gpgAgentPid}" 2>/dev/null; then
        GPG_AGENT_INFO=$(< "${lockFile}")
        export GPG_AGENT_INFO
        local logMessage="gpg-agent already running, "
        logMessage+="exported \$GPG_AGENT_INFO as $GPG_AGENT_INFO"
        log-to-zsh-init-log "${logMessage}"
    else
        eval $(gpg-agent --daemon --write-env-file "${lockFile}" \
                         --log-file "${gpgAgentLog}")
        echo $GPG_AGENT_INFO > "${lockFile}"
        local logMessage="Started gpg-agent, "
        logMessage+="wrote \$GPG_AGENT_INFO to ${lockFile}"
        log-to-zsh-init-log "${logMessage}"
    fi
}


function reload-zshrc() {
    source ~/.zshrc
}

function reload-zshrc-profile() {
    ZSH_PROFILE_RC=1 reload-zshrc
    zprof | less
}

function setup-prompt() {
    include "${HOME}/.config/zsh/current-org-task.zsh"
    include "${HOME}/.config/zsh/prompt.zsh"
}

function reload-prompt() {
    include "${HOME}/.config/zsh/prompt.zsh"
}

# Package Setup

# Set keystrokes for substring searching
function setup-zsh-history-substring-search() {
    # OPTION 1: for most systems
    zmodload zsh/terminfo
    bindkey "$terminfo[kcuu1]" history-substring-search-up
    bindkey "$terminfo[kcud1]" history-substring-search-down

    # OPTION 2: for iTerm2 running on Apple MacBook laptops
    zmodload zsh/terminfo
    bindkey "$terminfo[cuu1]" history-substring-search-up
    bindkey "$terminfo[cud1]" history-substring-search-down

    ## EMACS mode ###########################################
    bindkey -M emacs '^P' history-substring-search-up
    bindkey -M emacs '^N' history-substring-search-down
}

# fzf is a general-purpose command-line fuzzy finder.
function setup-fzf() {
    local fzfPath="${HOME}/.dotfiles/vendor/fzf"

    add-to-path "${fzfPath}/bin" after
    add-to-manpath "${fzfPath}/man" after

    # Auto-completion
    [[ $- == *i* ]] && include "${fzfPath}/shell/completion.zsh" 2> /dev/null

    # Key bindings
    include "${fzfPath}/shell/key-bindings.zsh"
}

# Setup NPM so we can install global packages without root.  See
# http://stackoverflow.com/questions/10081293.
function setup-npm() {
  add-to-path-if-exists "${NPM_PACKAGES}/bin"
  add-to-manpath "${NPM_PACKAGES}/share/man"
}

function setup-personal-packages() {
    include "${HOME}/.config/zsh/extract.zsh"
    include "${HOME}/.config/zsh/eslint.zsh"
    include "${HOME}/.config/zsh/finances.zsh"
    include "${HOME}/.config/zsh/spectrum.zsh"
    include "${HOME}/.config/zsh/updater.zsh"
    include "${HOME}/.config/zsh/test-fonts.zsh"
    include "${HOME}/.config/zsh/current-org-task.zsh"
}

setup-init-log
setup-env-variables
setup-zgen
setup-npm

# Path Setup
#
# View adding paths without a second arg of after like a stack, so the last
# entry is the first directory searched for executables.
add-to-path-if-exists "/usr/share/texmf-dist/scripts/texlive"
add-to-path-if-exists "${HOME}/.cask/bin"
add-to-path "/usr/local/bin"
add-to-path-if-exists "/usr/local/sbin"
add-to-path-if-exists "$HOME/homebrew/bin"

# Add coreutils to path
command -v brew >/dev/null 2>&1 && [ -d "$(brew --prefix coreutils)/libexec/gnubin" ] && \
    add-to-path "$(brew --prefix coreutils)/libexec/gnubin"

add-to-path "$HOME/bin"
add-to-path "$HOME/bin-system"

setup-gpg
# setup-gpg-agent
setup-zsh-history-substring-search
setup-prompt
setup-personal-packages
setup-fzf

alias g='git'
alias gRl='git remote --verbose'

alias kl='k -l'
alias ka='k -a'
alias kh='k -h'

alias rz='reload-zshrc'
alias rp='reload-prompt'

alias hl='hledger -f ~/gdrive/financials/personal.ledger'

include "${HOME}/.zsh-system.zsh"
