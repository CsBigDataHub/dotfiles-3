#!/bin/zsh

# ZSH loads the following files in order on startup for interactive shells.
# /etc/zshenv
# ~/.zshenv
# /etc/zprofile
# ~/.zprofile
# /etc/zshrc
# ~/.zshrc
# /etc/zlogin
# ~/.zlogin


# Log zsh startup information to this file.  Used mainly to debug why files
# aren't sourced and $PATH isn't updated.
INIT_LOG_FILE="${HOME}/.zsh-init-log"

function setup-init-log() {
    if [[ -f "${INIT_LOG_FILE}" ]]; then
        touch "${INIT_LOG_FILE}"
    fi

    # Clear the file
    echo -n '' > "${INIT_LOG_FILE}"
}

function log-to-zsh-init-log() {
    printf "%s\n" "$1" >> "${INIT_LOG_FILE}"
}

function show-init-log() {
    cat "${INIT_LOG_FILE}"
}

# For profiling, execute 'ZSH_PROFILE_RC=1 zsh'.  After loading a new shell, run
# `zprof | less`.
if [[ $ZSH_PROFILE_RC -gt 0 ]] ; then
    zmodload zsh/zprof
fi

GRML_OSTYPE=$(uname -s)

is_linux(){
    [[ $GRML_OSTYPE == "Linux" ]]
}

isdarwin(){
    [[ $GRML_OSTYPE == "Darwin" ]]
}

# Check for user and if not running as root set $SUDO to sudo.  Enables using
# "$SUDO" in command definitions.
(( EUID != 0 )) && SUDO='sudo' || SUDO=''

HISTFILE=$HOME/.zsh_history
HISTSIZE=10000
SAVEHIST=10000

# This option is a variant of INC_APPEND_HISTORY in which, where possible, the
# history entry is written out to the file after the command is finished, so
# that the time taken by the command is recorded correctly in the history file
# in EXTENDED_HISTORY format. This means that the history entry will not be
# available immediately from other instances of the shell that are using the
# same history file.
setopt inc_append_history_time

# Save each command’s beginning timestamp (in seconds since the epoch) and the
# duration (in seconds) to the history file. The format of this prefixed data
# is:
#
# : <beginning time>:<elapsed seconds>;<command>
# : 1472088207:4;sleep 4
setopt extended_history

# If a new command line being added to the history list duplicates an older one,
# the older command is removed from the list (even if it is not the previous
# event).
setopt hist_ignore_all_dups

# Remove command lines from the history list when the first character on the
# line is a space, or when one of the expanded aliases contains a leading
# space. Only normal aliases (not global or suffix aliases) have this behaviour.
setopt hist_ignore_space

# If a command is issued that can’t be executed as a normal command, and the
# command is the name of a directory, perform the cd command to that
# directory.
setopt auto_cd

# Display PID when suspending processes.
setopt long_list_jobs

# Report the status of backgrounds jobs immediately.
setopt notify

# Whenever a command completion or spelling correction is attempted, make sure
# the entire command path is hashed first. This makes the first completion
# slower but avoids false reports of spelling errors.
setopt hash_list_all

# If unset, the cursor is set to the end of the word if completion is
# started. Otherwise it stays there and completion is done from both ends.
setopt complete_in_word

# Don't send SIGHUP to background processes when the shell exits.
setopt nohup

# Disable field splitting on unquoted parameter expansion.  This is different
# from bash. For example
#
# var='foo bar'
# args() { echo $#; }
# args $var // produces 1, because zsh passes the string 'foo bar'.
setopt no_sh_word_split

# Avoid beeping on error in ZLE.
setopt no_beep

# Make cd push the old directory onto the directory stack.
setopt auto_pushd

# Don’t push multiple copies of the same directory onto the directory stack.
setopt pushd_ignore_dups

# Treat unset parameters as if they were empty when substituting. Otherwise they
# are treated as an error.
setopt unset

# Declare global (-g), array (-a) parameters.
typeset -ga ls_options
typeset -ga grep_options
if ls --color=auto / >/dev/null 2>&1; then
    ls_options+=( --color=auto )
elif ls -G / >/dev/null 2>&1; then
    ls_options+=( -G )
fi
if grep --color=auto -q "a" <<< "a" >/dev/null 2>&1; then
    grep_options+=( --color=auto )
fi

# Utility functions.

# Checks if a command exists and returns either true or false. This avoids using
# 'which' and 'whence', which will avoid problems with aliases for which on
# certain weird systems.
#
# Usage: check_com [-c|-g] word
#   -c  only checks for external commands
#   -g  does the usual tests and also checks for global aliases
check_com() {
    emulate -L zsh
    local -i comonly gatoo
    comonly=0
    gatoo=0

    if [[ $1 == '-c' ]] ; then
        comonly=1
        shift 1
    elif [[ $1 == '-g' ]] ; then
        gatoo=1
        shift 1
    fi

    if (( ${#argv} != 1 )) ; then
        printf 'usage: check_com [-c|-g] <command>\n' >&2
        return 1
    fi

    if (( comonly > 0 )) ; then
        (( ${+commands[$1]}  )) && return 0
        return 1
    fi

    if     (( ${+commands[$1]}    )) \
        || (( ${+functions[$1]}   )) \
        || (( ${+aliases[$1]}     )) \
        || (( ${+reswords[(r)$1]} )) ; then
        return 0
    fi

    if (( gatoo > 0 )) && (( ${+galiases[$1]} )) ; then
        return 0
    fi

    return 1
}

# Color setup for ls.
check_com -c dircolors && eval $(dircolors -b)
# Color setup for ls on OS X / FreeBSD.
isdarwin && export CLICOLOR=1

# Automatically remove duplicates from these arrays.  Only keeps the first
# occurence of each duplicated value.
# TODO: This seems to erase the variables.  Why?
# typeset -U path cdpath fpath manpath

# Completion configuration.

# The complist module offers two extensions to completion listings: the ability
# to highlight matches in such a list and a different style of menu-completion
zmodload zsh/complist

# The `-U` flag suppresses alias expansion and is recommended for functions
# supplied with zsh.  The `-z` flag marks the function to be loaded natively
# instead of with ksh emulation.  See
# http://stackoverflow.com/questions/12570749
autoload -Uz compinit
if [[ ! -d "${ZDOTDIR:-$HOME}/.zcompdumps" ]]; then
    mkdir -m 0700 -p "${ZDOTDIR:-$HOME}/.zcompdumps"
fi
compinit -d "${ZDOTDIR:-$HOME}/.zcompdumps/${HOST%%.*}-$ZSH_VERSION"

# http://zsh.sourceforge.net/Doc/Release/Completion-System.html#Completion-System
#
# zstyle configures like so:
#
# zstyle <context> <styles>
#
# The context defines where the style will apply. The context is a string of `:`
# separated strings: Some
#
# :completion:function:completer:command:argument:tag
#
# Some parts can be replaced by *, so that :completion: is the least specific
# context. More specific context wins over less specific ones of course.
#
# https://github.com/zsh-users/zsh-completions/blob/master/zsh-completions-howto.org
# has an in-depth explanation on how to write your own completions.
function setup-completion() {
    # Complete with heuristic of one error per 3 character typed.
    zstyle ':completion:*:approximate:*' \
           max-errors 'reply=( $(( ($#PREFIX+$#SUFFIX)/3 )) numeric )'

    # Don't complete backup files as executables.
    zstyle ':completion:*:complete:-command-::commands' \
           ignored-patterns '(aptitude-*|*\~)'

    # Start menu completion only if it could find no unambiguous initial string.
    zstyle ':completion:*:correct:*' insert-unambiguous true
    zstyle ':completion:*:corrections' \
           format $'%{\e[0;31m%}%d (errors: %e)%{\e[0m%}'
    zstyle ':completion:*:correct:*' original true

    # Activate color-completion.
    zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}

    # Format descriptions (notice the vt100 escapes).
    zstyle ':completion:*:descriptions' \
           format $'%{\e[0;31m%}completing %B%d%b%{\e[0m%}'

    # Insert all expansions for expand completer.
    zstyle ':completion:*:expand:*' tag-order all-expansions
    zstyle ':completion:*:history-words' list false

    # Activate menu.
    zstyle ':completion:*:history-words' menu yes

    # Ignore duplicate entries.
    zstyle ':completion:*:history-words' remove-all-dups yes
    zstyle ':completion:*:history-words' stop yes

    # Match uppercase from lowercase.
    zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'

    # Use the tag name as group name.
    zstyle ':completion:*:matches' group 'yes'
    zstyle ':completion:*' group-name ''

    # If there are more than 5 options allow selecting from a menu.
    zstyle ':completion:*' menu select=5

    zstyle ':completion:*:messages' format '%d'
    zstyle ':completion:*:options' auto-description '%d'

    # Describe options in full.
    zstyle ':completion:*:options' description 'yes'

    # On processes completion complete all user processes.
    zstyle ':completion:*:processes' command 'ps -au$USER'

    # Offer indexes before parameters in subscripts.
    zstyle ':completion:*:*:-subscript-:*' tag-order indexes parameters

    # Provide verbose completion information.
    zstyle ':completion:*' verbose true

    # Zsh versions are able to provide descriptions for commands (read: 1st word
    # in the line) that it will list for the user to choose from. The following
    # disables that, because it's not exactly fast.
    zstyle ':completion:*:-command-:*:' verbose false

    # Set format for warnings.
    zstyle ':completion:*:warnings' \
           format $'%{\e[0;31m%}No matches for:%{\e[0m%} %d'

    # Define files to ignore for zcompile.
    zstyle ':completion:*:*:zcompile:*' ignored-patterns '(*~|*.zwc)'
    zstyle ':completion:correct:' prompt 'correct to: %e'

    # Ignore completion functions for commands you don't have:
    zstyle ':completion::(^approximate*):*:functions' ignored-patterns '_*'

    # Provide more processes in completion of programs like killall:
    zstyle ':completion:*:processes-names' \
           command 'ps c -u ${USER} -o command | uniq'

    # complete manual by their section
    zstyle ':completion:*:manuals' separate-sections true
    zstyle ':completion:*:manuals.*'  insert-sections   true
    zstyle ':completion:*:man:*' menu yes select

    # Search path for sudo completion
    zstyle ':completion:*:sudo:*' command-path /usr/local/sbin \
                                               /usr/local/bin  \
                                               /usr/sbin       \
                                               /usr/bin        \
                                               /sbin           \
                                               /bin            \
                                               /usr/X11R6/bin

    # Provide .. as a completion.
    zstyle ':completion:*' special-dirs ..

    # Run rehash on completion so new installed program are found automatically.
    _force_rehash() {
        (( CURRENT == 1 )) && rehash
        return 1
    }

    # Try to be smart about when to use what completer...
    setopt correct
    zstyle -e ':completion:*' completer '
            if [[ $_last_try != "$HISTNO$BUFFER$CURSOR" ]] ; then
                _last_try="$HISTNO$BUFFER$CURSOR"
                reply=(_complete _match _ignored _prefix _files)
            else
                if [[ $words[1] == (rm|mv) ]] ; then
                    reply=(_complete _files)
                else
                    reply=(_oldlist _expand _force_rehash _complete _ignored \
                           _correct _approximate _files)
                fi
            fi'

    # Command for process lists, the local web server details and host
    # completion.
    zstyle ':completion:*:urls' local 'www' '/var/www/' 'public_html'

    # Some functions, like _apt and _dpkg, are very slow. We can use a cache in
    # order to speed things up.
    zstyle ':completion:*' use-cache yes 
    zstyle ':completion:*' cache-path ~/.zsh/cache

    [[ -r ~/.ssh/config ]] \
        && _ssh_config_hosts=(${${(s: :)${(ps:\t:)${${(@M)${(f)"$(<$HOME/.ssh/config)"}:#Host *}#Host }}}:#*[*?]*}) \
        || _ssh_config_hosts=()

    [[ -r ~/.ssh/known_hosts ]] \
        && _ssh_hosts=(${${${${(f)"$(<$HOME/.ssh/known_hosts)"}:#[\|]*}%%\ *}%%,*}) \
        || _ssh_hosts=()

    [[ -r /etc/hosts ]] \
        && : ${(A)_etc_hosts:=${(s: :)${(ps:\t:)${${(f)~~"$(</etc/hosts)"}%%\#*}##[:blank:]#[^[:blank:]]#}}} \
        || _etc_hosts=()
            
    hosts=(
        $(hostname)
        "$_ssh_config_hosts[@]"
        "$_ssh_hosts[@]"
        "$_etc_hosts[@]"
        localhost
    )
    zstyle ':completion:*:hosts' hosts $hosts


    # Use generic completion system for programs not yet defined; (_gnu_generic
    # works with commands that provide a --help option with "standard" gnu-like
    # output.)
    for compcom in cp deborphan df feh fetchipac gpasswd head hnb ipacsum mv \
                      pal stow uname ; do
        [[ -z ${_comps[$compcom]} ]] && compdef _gnu_generic ${compcom}
    done; unset compcom
}

# The key sequence ESC h is normally bound by ZLE to execute the run-help widget
# (see Zsh Line Editor). This invokes the run-help command with the command word
# from the current input line as its argument. By default, run-help is an alias
# for the man command, so this often fails when the command word is a shell
# builtin or a user-defined function. By redefining the run-help alias, one can
# improve the on-line help provided by the shell.
#
# Use zsh-aware run-help instead of just man.
unalias run-help &> /dev/null
autoload run-help

autoload colors
if [[ "$terminfo[colors]" -gt 8 ]]; then
    colors
fi

# The zsh/parameter module gives access to some of the internal hash tables used
# by the shell by defining some special parameters.
# http://zsh.sourceforge.net/Doc/Release/Zsh-Modules.html#The-zsh_002fparameter-Module
zmodload zsh/parameter
# A ZLE function duplicating EMACS’ zap-to-char.
zmodload zsh/deltochar
# Standard scientific functions for use in mathematical evaluations.
zmodload zsh/mathfunc

# In zmodload, with -a, the given list of features is marked for autoload from
# the specified module, which may not yet be loaded.  Autoloading is specific to
# individual features; when the module is loaded only the requested feature is
# enabled.

# zstat: The command acts as a front end to the stat system call (see man page
# stat(2)). The same command is provided with two names; as the name stat is
# often used by an external command it is recommended that only the zstat form
# of the command is used. This can be arranged by loading the module with the
# command ‘zmodload -F zsh/stat b:zstat’.
zmodload -a zsh/stat zstat
# http://zsh.sourceforge.net/Doc/Release/Zsh-Modules.html#The-zsh_002fzpty-Module-1
zmodload -a zsh/zpty zpty
# The -p option is like the -b and -c options, but makes zmodload work on
# autoloaded parameters instead.
# Access to external files via a special associative array.
zmodload -ap zsh/mapfile mapfile

function include () {
    if [[ -e "$1" ]]; then
        log-to-zsh-init-log "Sourcing $1"
        source "$1"
    else
        log-to-zsh-init-log "WARNING: didn't source $1"
    fi
}

function print-white() {
    echo "$fg[white]$1$reset_color"
}

function print-info() {
    print-white "$1"
}

function print-green() {
    echo "$fg[green]$1$reset_color"
}

function print-success() {
    local message="$1"
    print-green "  ${message}"
}

function print-red() {
    echo "$fg[red]$1$reset_color"
}

function print-error() {
    local message="$1"
    print-red "ERROR: ${message}"
}

function setup-env-variables() {
    include "${HOME}/.shell-common.sh"
}

function setup-zgen() {
    include "${DOTFILES_HOME}/vendor/zgen/zgen.zsh"

    if ! zgen saved; then

        # Provides syntax highlighting like the fish shell while typing
        # interactive commands.
        zgen load zsh-users/zsh-syntax-highlighting

        # k is a zsh script / plugin to make directory listings more readable,
        # adding a bit of color and some git status information on files and
        # directories.
        zgen load supercrabtree/k

        # More completion files for zsh.
        zgen load zsh-users/zsh-completions src

        # A Zsh plugin to help remembering those shell aliases and Git aliases
        # you once defined.  Prints a help line reminding you of an alias for a
        # command you typed.
        zgen load djui/alias-tips

        # Type in any part of any previously entered command and press the UP
        # and DOWN arrow keys to cycle through the matching commands.  Substring
        # search must load search after zsh-syntax-highlighting.
        zgen load zsh-users/zsh-history-substring-search

        # With zsh-async you can run multiple asynchronous jobs, enforce unique
        # jobs (multiple instances of the same job will not run), flush all
        # currently running jobs and create multiple workers (each with their
        # own jobs). For each worker you can register a callback-function
        # through which you will be notified about the job results (job name,
        # return code, output and execution time).
        zgen load mafredri/zsh-async

        zgen load rupa/z

        # generate the init script from plugins above
        zgen save
    fi
}

function contains() {
    string="$1"
    substring="$2"
    if test "${string#*$substring}" != "$string"
    then
        return 0    # $substring is in $string
    else
        return 1    # $substring is not in $string
    fi
}

function add-to-colon-separated-env-var() {
    local envKey="$1"
    local envValue="${(P)1}"
    local pathToAdd="$2"
    local insertLocation="$3"

    if ! contains "${envValue}" "${pathToAdd}" ; then
        if [ "${insertLocation}" = "after" ] ; then
            eval "${envKey}=${envValue}:${pathToAdd}"
            log-to-zsh-init-log "Added ${pathToAdd} to \$${envKey} at back.  \$${envKey} is now: ${(P)envKey}"
        else
            eval "${envKey}=${pathToAdd}:${envValue}"
            log-to-zsh-init-log "Added ${pathToAdd} to \$${envKey} at back.  \$${envKey} is now: ${(P)envKey}"
        fi
    fi
}

function add-to-path () {
    add-to-colon-separated-env-var PATH "$1" "$2"
}

function add-to-manpath() {
    add-to-colon-separated-env-var MANPATH "$1" "$2"
}

function add-to-path-if-exists() {
    if [[ -d "$1" ]]; then
        add-to-path "$1" "$2"
    else
        log-to-zsh-init-log "WARNING: didn't add to \$PATH because path doesn't exist: $1"
    fi
}

# Fix binding for delete key.
bindkey '^[[P' delete-char

function setup-gpg() {
    GPG_TTY=$(tty)
    export GPG_TTY
    log-to-zsh-init-log "Exported \$GPG_TTY as $GPG_TTY"
}

function setup-gpg-agent() {
    local hostUniqueName="$(hostname)"
    local lockFile="${HOME}/.gnupg/gpg-agent-info-${hostUniqueName}"
    local gpgAgentPid=$(cut -d: -f 2 "${lockFile}")
    local gpgAgentLog="${HOME}/.gnupg/gpg-agent-log"
    # kill -0 $PID tests if $PID is running.
    if test -f "${lockFile}" && kill -0 "${gpgAgentPid}" 2>/dev/null; then
        GPG_AGENT_INFO=$(< "${lockFile}")
        export GPG_AGENT_INFO
        local logMessage="gpg-agent already running, "
        logMessage+="exported \$GPG_AGENT_INFO as $GPG_AGENT_INFO"
        log-to-zsh-init-log "${logMessage}"
    else
        eval $(gpg-agent --daemon --write-env-file "${lockFile}" \
                         --log-file "${gpgAgentLog}")
        echo $GPG_AGENT_INFO > "${lockFile}"
        local logMessage="Started gpg-agent, "
        logMessage+="wrote \$GPG_AGENT_INFO to ${lockFile}"
        log-to-zsh-init-log "${logMessage}"
    fi
}


function reload-zshrc() {
    source ~/.zshrc
}

function reload-zshrc-profile() {
    ZSH_PROFILE_RC=1 reload-zshrc
    zprof | less
}

function setup-prompt() {
    include "${HOME}/.config/zsh/current-org-task.zsh"
    include "${HOME}/.config/zsh/prompt.zsh"
}

function reload-prompt() {
    include "${HOME}/.config/zsh/prompt.zsh"
}

# Package Setup

# Set keystrokes for substring searching
function setup-zsh-history-substring-search() {
    # OPTION 1: for most systems
    zmodload zsh/terminfo
    bindkey "$terminfo[kcuu1]" history-substring-search-up
    bindkey "$terminfo[kcud1]" history-substring-search-down

    # OPTION 2: for iTerm2 running on Apple MacBook laptops
    zmodload zsh/terminfo
    bindkey "$terminfo[cuu1]" history-substring-search-up
    bindkey "$terminfo[cud1]" history-substring-search-down

    ## EMACS mode ###########################################
    bindkey -M emacs '^P' history-substring-search-up
    bindkey -M emacs '^N' history-substring-search-down
}

# fzf is a general-purpose command-line fuzzy finder.
function setup-fzf() {
    local fzfPath="${HOME}/.dotfiles/vendor/fzf"

    add-to-path "${fzfPath}/bin" after
    add-to-manpath "${fzfPath}/man" after

    # Auto-completion
    [[ $- == *i* ]] && include "${fzfPath}/shell/completion.zsh" 2> /dev/null

    # Key bindings
    include "${fzfPath}/shell/key-bindings.zsh"
}

# Setup NPM so we can install global packages without root.  See
# http://stackoverflow.com/questions/10081293.
function setup-npm() {
    add-to-path-if-exists "${NPM_PACKAGES}/bin"
    add-to-manpath "${NPM_PACKAGES}/share/man"
}

function setup-personal-packages() {
    include "${HOME}/.config/zsh/extract.zsh"
    include "${HOME}/.config/zsh/eslint.zsh"
    include "${HOME}/.config/zsh/finances.zsh"
    include "${HOME}/.config/zsh/utils.zsh"
    include "${HOME}/.config/zsh/spectrum.zsh"
    include "${HOME}/.config/zsh/updater.zsh"
    include "${HOME}/.config/zsh/test-fonts.zsh"
    include "${HOME}/.config/zsh/current-org-task.zsh"
}

setup-init-log
setup-env-variables
setup-zgen
setup-npm

# Path Setup
#
# View adding paths without a second arg of after like a stack, so the last
# entry is the first directory searched for executables.
add-to-path-if-exists "/usr/share/texmf-dist/scripts/texlive"
add-to-path-if-exists "${HOME}/.cask/bin"
add-to-path "/usr/local/bin"
add-to-path-if-exists "/usr/local/sbin"
add-to-path-if-exists "$HOME/homebrew/bin"

# Add coreutils to path
command -v brew >/dev/null 2>&1 && [ -d "$(brew --prefix coreutils)/libexec/gnubin" ] && \
    add-to-path "$(brew --prefix coreutils)/libexec/gnubin"

add-to-path "$HOME/bin"
add-to-path "$HOME/bin-system"

setup-completion
setup-gpg
# setup-gpg-agent
setup-zsh-history-substring-search
setup-prompt
setup-personal-packages
setup-fzf

alias g='git'
alias gRl='git remote --verbose'

alias kl='k -l'
alias ka='k -a'
alias kh='k -h'

alias rz='reload-zshrc'
alias rp='reload-prompt'

alias hl='hledger -f ~/gdrive/financials/personal.ledger'

include "${HOME}/.zsh-system.zsh"
