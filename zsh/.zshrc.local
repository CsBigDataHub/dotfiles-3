#!/bin/zsh

# ZSH loads the following files in order.
# 1. /etc/zshenv (always)
# If NO_RCS is set, none of the following are run.
# 2. ~/.zshenv (Usually run for all shells)
# 3. /etc/zprofile (login)
# 4. ~/.zprofile (login)
# 5. /etc/zshrc (interactive)
# 6.1 ~/.zshrc.pre (interactive for grml)
# 6.2 ~/.zshrc (interactive, this is grml)
# 6.3 ~/.zshrc.local (interactive by grml)
# 7. /etc/zlogin (login)
# 8. ~/.zlogin (login)
#
# If a login shell, the following are run on logout or exit.
# ~/.zlogout
# /etc/zlogout

# To profile, run this command.
# ZSH_PROFILE_RC=1 zsh && exit

# Measures the time taken for GRML and for this file.
if [[ $ZSH_PROFILE_RC -gt 0 ]] ; then
    float GRML_PROFILE_END_TIME=${EPOCHREALTIME}
    float -gx GRML_PROFILE_ELAPSED_TIME=$(( \
        (GRML_PROFILE_END_TIME - GRML_PROFILE_START_TIME) * 1000 ))
    float -gx ZSHRC_PROFILE_START_TIME=${EPOCHREALTIME}
fi

# Setup the man path.  It's already tied to MANPATH.
manpath=(/usr/man /usr/local/man)
typeset -U manpath
# TODO: enable me async
# rationalize-path manpath
# rationalize-path path

# This option is a variant of INC_APPEND_HISTORY in which, where possible, the
# history entry is written out to the file after the command is finished, so
# that the time taken by the command is recorded correctly in the history file
# in EXTENDED_HISTORY format. This means that the history entry will not be
# available immediately from other instances of the shell that are using the
# same history file.
setopt inc_append_history_time

autoload colors
if [[ "$terminfo[colors]" -gt 8 ]]; then
    colors
fi

function source-if-exists() {
    [[ -e "$1" ]] && source "$1"
}

function print-white() {
  echo "$fg[white]$1$reset_color"
}

function print-info() {
  print-white "$1"
}

function print-green() {
  echo "$fg[green]$1$reset_color"
}

function print-success() {
  local message="$1"
  print-green "ï€Œ  ${message}"
}

function print-red() {
  echo "$fg[red]$1$reset_color"
}

function print-error() {
  local message="$1"
  print-red "ERROR: ${message}"
}

function add-to-path () {
    path+="$1"
}

function add-to-manpath() {
    manpath+="$1"
}

function add-to-path-if-exists() {
    if [[ -d "$1" ]]; then
        path+="$1"
    fi
}

# Fix binding for delete key.
bindkey '^[[P' delete-char

function setup-gpg() {
    GPG_TTY=$(tty)
    export GPG_TTY
}

function setup-gpg-agent() {
    local hostUniqueName="$(hostname)"
    local lockFile="${HOME}/.gnupg/gpg-agent-info-${hostUniqueName}"
    local gpgAgentPid=$(cut -d: -f 2 "${lockFile}")
    local gpgAgentLog="${HOME}/.gnupg/gpg-agent-log"
    # kill -0 $PID tests if $PID is running.
    if test -f "${lockFile}" && kill -0 "${gpgAgentPid}" 2>/dev/null; then
        GPG_AGENT_INFO=$(< "${lockFile}")
        export GPG_AGENT_INFO
    else
        eval $(gpg-agent --daemon --write-env-file "${lockFile}" \
                         --log-file "${gpgAgentLog}")
        echo $GPG_AGENT_INFO > "${lockFile}"
    fi
}

function setup-prompt() {
    source-if-exists "${ZDOTDIR}/prompts/pure-prompt"
    # Secondary prompt, printed when the shell needs more information to
    # complete a command.
    PS2='\`%_> '
    # Selection prompt used within a select loop.
    PS3='?# '
    # The execution trace prompt (setopt xtrace). default: '+%N:%i>'
    PS4='+%N:%i:%_> '
}

# Package Setup

# fzf is a general-purpose command-line fuzzy finder.
function setup-fzf() {
    local fzfPath="${HOME}/.dotfiles/vendor/fzf"
    path+="${fzfPath}/bin"
    manpath+="${fzfPath}/man"

    # Key bindings
    source-if-exists "${fzfPath}/shell/key-bindings.zsh"
}

# Setup NPM so we can install global packages without root.  See
# http://stackoverflow.com/questions/10081293.
function setup-npm() {
  add-to-path-if-exists "${NPM_PACKAGES}/bin"
  add-to-manpath "${NPM_PACKAGES}/share/man"
}

# Setup Ruby and Gem so we install packages without root.
function setup-ruby() {
  add-to-path-if-exists "${GEM_HOME}/bin"
}

# Setup PATH and completion for gcloud.
function setup-gcloud() {
  source-if-exists "${HOME}/google-cloud-sdk/path.zsh.inc"
  source-if-exists "${HOME}google-cloud-sdk/completion.zsh.inc"
}

function is-google-corp-computer() {
  if [[ $(hostname) == *corp.google.com ]]; then
    return 0
  else
    return 1
  fi
}

function setup-google-packages() {
  if is-google-corp-computer; then
    source-if-exists "${HOME}/.config/zsh/google.zsh"
  fi
}

function setup-rust() {
    add-to-path-if-exists "${HOME}/.cargo/bin"
    export RUST_SRC_PATH="${HOME}/.multirust/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src"
}

function setup-yarn() {
  if ! command -v yarn >/dev/null; then
    add-to-path-if-exists "${HOME}/.yarn/bin"
  fi
}

function setup-zsh-async() {
    # Don't autoload because we need it immediately for the prompt.
    source-if-exists "${HOME}/.dotfiles/vendor/zsh-async/async.zsh"
}

function z() {
  source "${HOME}/.dotfiles/vendor/z/z.sh"
  # Load the real z function which will overwrite this function with an alias.
  _z "$@"
}

function setup-tmux-package-manager() {
    local TPM_HOME="${HOME}/.tmux/plugins/tpm"
    if [[ ! -d "${TPM_HOME}" ]]; then
        print-error "tmux package manager (TPM) is not installed at ${TPM_HOME}"
    fi
}

# Tmux inside the st terminal doesn't like it when TERM isn't xterm-256 and
# won't properly display the background color.  fzf, on the other hand only
# likes TERM to screen-256color.  So, let TERM start as xterm-256color, but
# after tmux is started we can safely change TERM to screen-256color to appease
# fzf.
function setup-256-color-hack-for-fzf() {
  if [[ -n "$TMUX" ]]; then
    export TERM='screen-256color'
  fi
}

# Setup completion directories
fpath=(~/.zsh/completions ~/.zsh/functions $fpath)

# Autoload all shell functions from all directories in $fpath (following
# symlinks) that have the executable bit on (the executable bit is not
# necessary, but gives you an easy way to stop the autoloading of a particular
# shell function). $fpath should not be empty for this to work.
for func in $^fpath/*(N-.x:t); autoload $func

# Keyboard shortcuts

# Store the current command and use it as the inital text for following
# commands.
bindkey '^[q' push-input

# Options
setopt interactive_comments


setup-zsh-async
setup-prompt
setup-npm
setup-ruby
setup-rust
setup-256-color-hack-for-fzf
setup-google-packages
setup-fzf
setup-gcloud
setup-yarn
setup-tmux-package-manager

alias g='git'
alias gRl='git remote --verbose'
alias kl='k -l'
alias ka='k -a'
alias kh='k -h'
alias rz='reload-zshrc'
alias e='emacsclient --no-wait'

export DISABLE_AUTO_TITLE='true'

if ! type 'blaze' > /dev/null; then
  alias blaze='bazel'
fi

alias hl='hledger -f ~/gdrive/financials/personal.ledger'
alias open='xdg-open'

if alias | grep -q '^ag='; then
  # This grml alias conflicts with the platinum searcher.
  unalias ag
fi

export MY_ZSH_SYSTEM_LOADED=''
source-if-exists "${HOME}/.zsh-system.zsh"

if [[ -z "${MY_ZSH_SYSTEM_LOADED}" ]]; then
  print-info "No ZSH system file loaded"
fi

if [[ $ZSH_PROFILE_RC -gt 0 ]] ; then
    float ZSHRC_PROFILE_END_TIME=${EPOCHREALTIME}
    float ZSHRC_ELAPSED_TIME=$(( \
        (ZSHRC_PROFILE_END_TIME - ZSHRC_PROFILE_START_TIME) * 1000 ))
    local grml_formatted_time=$(printf "%.0f" $GRML_PROFILE_ELAPSED_TIME)
    local zshrc_formatted_time=$(printf "%.0f" $ZSHRC_ELAPSED_TIME)
    print-info "GRML Load Time: ${grml_formatted_time}ms"
    print-info "ZSHRC Load Time: ${zshrc_formatted_time}ms"
    print-info "Type \`zprof | less\` to see detailed results."
fi
